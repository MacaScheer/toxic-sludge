{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/shape.js","webpack:///./src/board.js","webpack:///./src/index.js","webpack:///./src/elbow.js","webpack:///./src/straight.js","webpack:///./src/cross.js","webpack:///./src/game.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Elbow","require","Straight","Cross","Shape","type","id","xRange","yRange","ctx","isFull","this","orientationIndex","drawEntry","drawExit","drawSludgeEntry","asyncDrawSludgeEntry","async","sludgeStep","sleepFunction","beginPath","moveTo","lineTo","lineWidth","strokeStyle","stroke","console","log","ms","Promise","res","setTimeout","x","y","clearRect","reDraw","selectId","range","coords","split","map","parseInt","draw","drawShape","elbowIndex","straightIndex","validPipeFlow","nextPipe","prevDir","index","validFlow","drawSludge","returnVal","straight","elbow","Math","PI","cross","Board","height","width","types","shapesObj","j","floor","random","entry","exit","shape","fill","clickSpot","ranges","keys","selectShape","forEach","rangeArr","coordinates","direction","nextShape","Game","document","addEventListener","canvasEl","getElementById","getContext","board","createGrid","params","event","pageX","pageY","rotateShape","start","radius","asyncDrawSludge","orientationArr","offset_x","offset_y","end","openPoints","corner","outDir","outPoint","orientation","arc","newStart","newEnd","nextSpaceArr","Array","inDir","inPoint","includes","offset_x_1","offset_y_1","offset_x_2","offset_y_2","startX","startY","newOffset","isGameOver","play","dirString","directionOptionsObj","0","1","2","3","Date","getTime","entryReturn","fillEntryPipe","coordinateArr","findDirection","slice","getValidFlow","fillPipes"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","const Elbow = require(\"./elbow\");\n// const DblElbow = require(\"./dblElbow\");\nconst Straight = require(\"./straight\");\nconst Cross = require(\"./cross\");\n\nclass Shape {\n  constructor(type, id, xRange, yRange, ctx, isFull = false) {\n    this.xRange = xRange;\n    this.yRange = yRange;\n    this.type = type;\n    this.orientationIndex = id;\n    this.ctx = ctx;\n    this.isFull = isFull;\n    this.drawEntry = this.drawEntry.bind(this);\n    this.drawExit = this.drawExit.bind(this);\n    this.drawSludgeEntry = this.drawSludgeEntry.bind(this);\n    this.asyncDrawSludgeEntry = this.asyncDrawSludgeEntry.bind(this);\n  }\n}\n\n// Shape.prototype.drawBarrier = function(ctx, x, y) {\n//   ctx.rect(0, 0, 50, 50);\n//   ctx.fillStyle = \"black\";\n//   ctx.fill();\n//   ctx.stroke();\n// };\n\n// Shape.prototype.drawDblElbow = function(ctx, x, y) {\n//   ctx.beginPath();\n//   ctx.arc(x + 0, y + 0, 20, 0, 0.5 * Math.PI);\n//   ctx.moveTo(x + 25, y + 50);\n//   ctx.arc(x + 50, y + 50, 20, 1.5 * Math.PI, 2 * Math.PI);\n//   ctx.stroke();\n// };\n\nShape.prototype.drawSludgeEntry = async function(ctx, sludgeStep = 0) {\n  await this.sleepFunction(30);\n  sludgeStep += 0.25;\n  ctx.beginPath();\n  ctx.moveTo(0, 275);\n  ctx.lineTo(sludgeStep, 275);\n  ctx.lineWidth = 10;\n  ctx.strokeStyle = \"#32CD32\";\n  ctx.stroke();\n  ctx.strokeStyle = \"#000000\";\n\n  if (sludgeStep < 50) {\n    return this.asyncDrawSludgeEntry(ctx, sludgeStep);\n  } else {\n    console.log(\"done filling entry!\");\n    return \"0,50,100,250,300\";\n  }\n};\n\nShape.prototype.sleepFunction = function(ms) {\n  return new Promise(res => setTimeout(res, ms));\n};\n\nShape.prototype.asyncDrawSludgeEntry = function(ctx, sludgeStep) {\n  return this.drawSludgeEntry(ctx, sludgeStep);\n};\n\nShape.prototype.drawEntry = function(ctx, x, y) {\n  ctx.clearRect(x + 1, y + 1, 49, 49);\n  ctx.beginPath();\n  ctx.moveTo(x + 0, y + 25);\n  ctx.lineTo(x + 45, y + 25);\n  ctx.moveTo(x + 45, y + 10);\n  ctx.lineTo(x + 45, y + 40);\n  ctx.lineWidth = 15;\n  ctx.strokeStyle = \"#FCC201\";\n  ctx.stroke();\n  ctx.strokeStyle = \"#000000\";\n};\n\nShape.prototype.drawExit = function(ctx, x, y) {\n  ctx.clearRect(x + 1, y + 1, 49, 49);\n  ctx.beginPath();\n  ctx.moveTo(x + 50, y + 25);\n  ctx.lineTo(x + 5, y + 25);\n  ctx.moveTo(x + 5, y + 10);\n  ctx.lineTo(x + 5, y + 40);\n  ctx.lineWidth = 15;\n  ctx.strokeStyle = \"#FCC201\";\n  ctx.stroke();\n  ctx.strokeStyle = \"#000000\";\n};\n\nShape.prototype.reDraw = function(selectId, range, ctx, type) {\n  let coords = range.split(\",\").map(s => parseInt(s));\n  switch (type) {\n    case \"elbow\":\n      let elbow = new Elbow(selectId, ctx);\n      elbow.draw(ctx, coords[0], coords[2]);\n      break;\n    case \"straight\":\n      let straight = new Straight(selectId, ctx);\n      straight.draw(ctx, coords[0], coords[2]);\n      break;\n  }\n};\n\nShape.prototype.drawShape = async function(ctx, x, y) {\n  switch (this.type) {\n    case \"cross\":\n      let cross = new Cross(ctx);\n      cross.draw(ctx, x, y);\n      break;\n    case \"elbow\":\n      let elbowIndex = this.orientationIndex;\n      let elbow = new Elbow(elbowIndex, ctx);\n      elbow.draw(ctx, x, y);\n      break;\n    case \"straight\":\n      let straightIndex = this.orientationIndex;\n      let straight = new Straight(straightIndex, ctx);\n      straight.draw(ctx, x, y);\n      break;\n    // case \"dblElbow\":\n    //   this.drawDblElbow(ctx, x, y);\n    //   break;\n    // case \"barrier\":\n    //this could be a wildcard space\n    //that fills with sludge and routes to all contiguous openings\n    //   this.drawBarrier(ctx, x, y);\n    //   break;\n    case \"entry\":\n      this.drawEntry(ctx, x, y);\n      break;\n    case \"exit\":\n      this.drawExit(ctx, x, y);\n  }\n};\n\nShape.prototype.validPipeFlow = function(nextPipe, prevDir) {\n  let type = nextPipe.type;\n  let index = nextPipe.orientationIndex;\n  switch (type) {\n    case \"straight\":\n      let straight = new Straight(index, this.ctx);\n      return straight.validFlow(prevDir);\n    case \"elbow\":\n      let elbow = new Elbow(index, this.ctx);\n      return elbow.validFlow(prevDir);\n    case \"cross\":\n      return true;\n  }\n};\nShape.prototype.drawSludge = async function(nextPipe, prevDir, ctx) {\n  let index = nextPipe.orientationIndex;\n  // this.isFull = true;\n  // console.log(\"index: \", index);\n  let x = nextPipe.xRange[0];\n  let y = nextPipe.yRange[0];\n  let returnVal;\n  switch (nextPipe.type) {\n    case \"straight\":\n      let straight = new Straight(index, ctx);\n      returnVal = await straight.drawSludge(ctx, x, y, prevDir, 1, index);\n      return returnVal;\n\n    case \"elbow\":\n      let elbow = new Elbow(index, ctx);\n      console.log(\"shape class ELBOW PREVDIR: \", prevDir);\n\n      returnVal = await elbow.drawSludge(\n        ctx,\n        x,\n        y,\n        prevDir,\n        (0.5 * Math.PI) / 200,\n        index\n      );\n      return returnVal;\n\n    case \"cross\":\n      console.log(\"shape class CROSS PREVDIR: \", prevDir);\n      let cross = new Cross(index, ctx);\n      returnVal = await cross.drawSludge(ctx, x, y, prevDir, 1, index);\n      console.log(\"DRAWSLUDGE RETURN VAL IN SHAPE: \", returnVal);\n      return returnVal;\n  }\n};\n\nmodule.exports = Shape;\n","const Shape = require(\"./shape.js\");\n\nclass Board {\n  constructor(height, width, ctx) {\n    this.width = width;\n    this.height = height;\n    this.types = [\"elbow\", \"straight\", \"cross\", \"elbow\"];\n    this.shapesObj = {};\n    this.ctx = ctx;\n  }\n\n  createGrid(ctx) {\n    ctx.beginPath();\n\n    for (let x = 0, i = 0; i < 14; x += 50, i++) {\n      ctx.moveTo(0, x);\n      ctx.lineTo(750, x);\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    }\n    for (let x = 0, i = 0; i < 16; x += 50, i++) {\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, 650);\n      ctx.stroke();\n    }\n\n    for (let x = 0, i = 0; i < 15; x += 50, i++) {\n      for (let y = 0, j = 0; j < 13; y += 50, j++) {\n        let type = this.types[Math.floor(Math.random() * 3)];\n        let xRange = [x, x + 50];\n        let yRange = [y, y + 50];\n        if (x === 0 && y === 250) {\n          const entry = new Shape(\"entry\", 1, xRange, yRange, this.ctx);\n          // console.log(\"ENTRY COORDINATES: \", x, y);\n          entry.drawShape(ctx, x, y);\n          this.shapesObj[[xRange, yRange]] = entry;\n          // console.log(\"ShapesObj: \", this.shapesObj);\n        } else if (x === 700 && y === 250) {\n          const exit = new Shape(\"exit\", 0, xRange, yRange, this.ctx);\n          exit.drawShape(ctx, x, y);\n          this.shapesObj[[xRange, yRange]] = exit;\n        } else {\n          let id;\n          if (type === \"elbow\") {\n            id = Math.floor(Math.random() * 4);\n          }\n          if (type === \"straight\") {\n            id = Math.floor(Math.random() * 2);\n          }\n          const shape = new Shape(type, id, xRange, yRange, ctx);\n          shape.drawShape(ctx, x, y);\n          this.shapesObj[[xRange, yRange]] = shape;\n        }\n      }\n    }\n    ctx.fill();\n  }\n\n  rotateShape(clickSpot) {\n    let [x, y] = [clickSpot[0], clickSpot[1]];\n    const ranges = Object.keys(this.shapesObj);\n    let selectShape;\n    ranges.forEach(range => {\n      let rangeArr = range.split(\",\").map(s => parseInt(s));\n      if (\n        x >= rangeArr[0] &&\n        x <= rangeArr[1] &&\n        y >= rangeArr[2] &&\n        y <= rangeArr[3]\n      ) {\n        selectShape = this.shapesObj[range];\n\n        let selectId = selectShape.orientationIndex;\n        \n        console.log(\"SELECT SHAPE\", selectShape);\n        //replace old object with new one\n        if (!this.isFull) {\n          if (selectShape.type === \"elbow\") {\n            selectId = Math.floor((selectId + 1) % 4);\n            selectShape.reDraw(selectId, range, this.ctx, selectShape.type);\n            this.shapesObj[range].orientationIndex = selectId;\n            // console.log(\"ROTATE, new orientationIDX: \", this.shapesObj[range]);\n          }\n          if (selectShape.type === \"straight\") {\n            selectId = Math.floor((selectId + 1) % 2);\n            selectShape.reDraw(selectId, range, this.ctx, selectShape.type);\n            this.shapesObj[range].orientationIndex = selectId;\n            // console.log(\"ROTATE, new orientationIDX: \", this.shapesObj[range]);\n          }\n        }\n      }\n    });\n  }\n\n  findDirection(coordinates, direction) {\n    let nextShape = this.shapesObj[coordinates];\n\n    return nextShape;\n  }\n\n  getValidFlow(prevDir, nextPipe) {\n    let nextType = nextPipe.type;\n    if (nextType === \"cross\") {\n      return true;\n    } else {\n      return nextPipe.validPipeFlow(nextPipe, prevDir);\n    }\n  }\n  async fillEntryPipe() {\n    const entry = new Shape(\"entry\", 1, [0, 50], [250, 300], this.ctx);\n    // console.log(\"ENTRY: \", entry);\n    let returnVal = await entry.drawSludgeEntry(this.ctx);\n    return returnVal;\n  }\n  async fillPipes(direction, nextShape) {\n    console.log(\"SHAPES OBJECT:  \", this.shapesObj);\n    console.log(\"SHAPE from fillPIPE() in BOARD\", nextShape);\n    let returnVal = await nextShape.drawSludge(nextShape, direction, this.ctx);\n    console.log(\"BOARD FILLPIPES RETURN VAL: \", returnVal);\n    return returnVal;\n  }\n}\n\nmodule.exports = Board;\n","const Board = require(\"./board\");\nconst Game = require(\"./game\");\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  const canvasEl = document.getElementById(\"gameboard\");\n  const ctx = canvasEl.getContext(\"2d\");\n  let board = new Board(400, 800, ctx);\n  board.createGrid(ctx);\n  canvasEl.addEventListener(\"click\", function(params) {\n    let clickSpot = [event.pageX, event.pageY];\n    board.rotateShape(clickSpot);\n  });\n  const game = new Game(board);\n  game.start();\n});\n","// const Shape = require(\"./shape\");\n\nclass Elbow {\n  constructor(index, ctx, isFull = false) {\n    this.orientationIndex = index;\n    this.radius = 25;\n    this.ctx = ctx;\n    this.isFull = isFull;\n    this.drawSludge = this.drawSludge.bind(this);\n    this.asyncDrawSludge = this.asyncDrawSludge.bind(this);\n    this.orientationArr = [\n      {\n        offset_x: 0,\n        offset_y: 0,\n        start: 0 * Math.PI,\n        end: 0.5 * Math.PI,\n        openPoints: [\"left\", \"top\"],\n        corner: \"topLeft\"\n      },\n      {\n        offset_x: 50,\n        offset_y: 0,\n        start: 0.5 * Math.PI,\n        end: 1 * Math.PI,\n        openPoints: [\"top\", \"right\"],\n        corner: \"topRight\"\n      },\n      {\n        offset_x: 0,\n        offset_y: 50,\n        start: 1.5 * Math.PI,\n        end: 2 * Math.PI,\n        openPoints: [\"left\", \"bottom\"],\n        corner: \"bottomLeft\"\n      },\n      {\n        offset_x: 50,\n        offset_y: 50,\n        start: 1 * Math.PI,\n        end: 1.5 * Math.PI,\n        openPoints: [\"right\", \"bottom\"],\n        corner: \"bottomRight\"\n      }\n    ];\n    this.outDir = \"\";\n    this.outPoint = \"\";\n  }\n\n  draw(ctx, x, y) {\n    if (!this.isFull) {\n      let orientation = this.orientationArr[this.orientationIndex];\n      ctx.clearRect(x + 1, y + 1, 49, 49);\n      ctx.beginPath();\n      ctx.arc(\n        x + orientation.offset_x,\n        y + orientation.offset_y,\n        this.radius,\n        orientation.start,\n        orientation.end\n      );\n      ctx.lineWidth = 15;\n      ctx.stroke();\n    }\n  }\n\n  async drawSludge(ctx, x, y, prevDir, sludgeStep, index) {\n    this.isFull = true;\n    let orientation = this.orientationArr[index];\n    let newStart, newEnd;\n    await this.sleepFunction(30);\n    ctx.beginPath();\n    const nextSpaceArr = new Array(5);\n    // positive arc direction\n    if (prevDir === \"right\" && orientation.corner === \"bottomLeft\") {\n      newStart = 1.5 * Math.PI;\n      newEnd = newStart + sludgeStep;\n      nextSpaceArr[0] = 1;\n      nextSpaceArr[1] = x + orientation.offset_x;\n      nextSpaceArr[2] = x + orientation.offset_x + 50;\n      nextSpaceArr[3] = y + orientation.offset_y;\n      nextSpaceArr[4] = y + orientation.offset_y + 50;\n      // console.log(\"BOTTOM LEFT:\", nextSpaceArr);\n    }\n    if (prevDir === \"down\" && orientation.corner === \"topLeft\") {\n      debugger;\n      newStart = 0;\n      newEnd = newStart + sludgeStep;\n      nextSpaceArr[0] = 2;\n      nextSpaceArr[1] = x + orientation.offset_x - 50;\n      nextSpaceArr[2] = x + orientation.offset_x;\n      nextSpaceArr[3] = y + orientation.offset_y;\n      nextSpaceArr[4] = y + orientation.offset_y + 50;\n      //PROBLEM WITH THIS PART ^^\n    }\n    if (prevDir === \"up\" && orientation.corner === \"bottomRight\") {\n      debugger;\n\n      newStart = 1 * Math.PI;\n      newEnd = newStart + sludgeStep;\n      nextSpaceArr[0] = 0;\n      nextSpaceArr[1] = x + orientation.offset_x;\n      nextSpaceArr[2] = x + orientation.offset_x + 50;\n      nextSpaceArr[3] = y + orientation.offset_y - 50;\n      nextSpaceArr[4] = y + orientation.offset_y;\n    }\n    if (prevDir === \"left\" && orientation.corner === \"topRight\") {\n      debugger;\n\n      newStart = 0.5 * Math.PI;\n      newEnd = newStart + sludgeStep;\n      nextSpaceArr[0] = 3;\n      nextSpaceArr[1] = x + orientation.offset_x - 50;\n      nextSpaceArr[2] = x + orientation.offset_x;\n      nextSpaceArr[3] = y + orientation.offset_y - 50;\n      nextSpaceArr[4] = y + orientation.offset_y;\n    }\n    // negative arc direction\n    if (prevDir === \"up\" && orientation.corner === \"bottomLeft\") {\n      debugger;\n      newStart = 0 * Math.PI;\n      newEnd = newStart - sludgeStep;\n      nextSpaceArr[0] = 2;\n      nextSpaceArr[1] = x + orientation.offset_x - 50;\n      nextSpaceArr[2] = x + orientation.offset_x;\n      nextSpaceArr[3] = y + orientation.offset_y - 50;\n      nextSpaceArr[4] = y + orientation.offset_y;\n    }\n    if (prevDir === \"left\" && orientation.corner === \"bottomRight\") {\n      debugger;\n      newStart = 1.5 * Math.PI;\n      newEnd = newStart - sludgeStep;\n      nextSpaceArr[0] = 1;\n      nextSpaceArr[1] = x + orientation.offset_x - 50;\n      nextSpaceArr[2] = x + orientation.offset_x;\n      nextSpaceArr[3] = y + orientation.offset_y;\n      nextSpaceArr[4] = y + orientation.offset_y + 50;\n    }\n    if (prevDir === \"right\" && orientation.corner === \"topLeft\") {\n      //makes a loop\n      debugger;\n      newStart = 0.5 * Math.PI;\n      newEnd = newStart - sludgeStep;\n      console.log(\"ELBOW INCREMENTS newStart: \", newStart);\n      console.log(\"ELBOW INCREMENTS newEnd: \", newEnd);\n      console.log(\"ELBOW INCREMENTS: sludgeStep\", sludgeStep);\n      nextSpaceArr[0] = 3;\n      nextSpaceArr[1] = x + orientation.offset_x;\n      nextSpaceArr[2] = x + orientation.offset_x + 50;\n      nextSpaceArr[3] = y + orientation.offset_y - 50;\n      nextSpaceArr[4] = y + orientation.offset_y;\n      // console.log(\"TOP LEFT:\", nextSpaceArr);\n    }\n    if (prevDir === \"down\" && orientation.corner === \"topRight\") {\n      // makes a loop\n      debugger;\n      newStart = 1 * Math.PI;\n      newEnd = newStart - sludgeStep;\n      console.log(\"ELBOW INCREMENTS newStart: \", newStart);\n      console.log(\"ELBOW INCREMENTS newEnd: \", newEnd);\n      console.log(\"ELBOW INCREMENTS: sludgeStep\", newStart);\n\n      nextSpaceArr[0] = 0;\n      nextSpaceArr[1] = x + orientation.offset_x;\n      nextSpaceArr[2] = x + orientation.offset_x + 50;\n      nextSpaceArr[3] = y + orientation.offset_y;\n      nextSpaceArr[4] = y + orientation.offset_y + 50;\n    }\n    ctx.arc(\n      x + orientation.offset_x,\n      y + orientation.offset_y,\n      this.radius,\n      newStart,\n      newEnd\n    );\n\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = \"#32CD32\";\n    ctx.stroke();\n    ctx.strokeStyle = \"#000000\";\n\n    if (sludgeStep < 0.5 * Math.PI) {\n      return this.asyncDrawSludge(\n        x,\n        y,\n        prevDir,\n        sludgeStep + (0.5 * Math.PI) / 200,\n        index\n      );\n    } else {\n      console.log(\"Done filling ELBOW PIPE!\", nextSpaceArr);\n      return nextSpaceArr;\n    }\n  }\n  //sludgeStep should be (.5 * Math.PI)/200\n  sleepFunction(ms) {\n    return new Promise(res => setTimeout(res, ms));\n  }\n  asyncDrawSludge(x, y, prevDir, sludgeStep, index) {\n    return this.drawSludge(this.ctx, x, y, prevDir, sludgeStep, index);\n  }\n\n  validFlow(inDir) {\n    console.log(\"INDIR\", inDir);\n    let inPoint;\n    switch (inDir) {\n      case \"up\":\n        inPoint = \"bottom\";\n        break;\n      case \"down\":\n        inPoint = \"top\";\n        break;\n      case \"right\":\n        inPoint = \"left\";\n        break;\n      case \"left\":\n        inPoint = \"right\";\n        break;\n    }\n    let openPoints = this.orientationArr[this.orientationIndex].openPoints;\n    console.log(\"OPENPOINTS INCLUDES?:\", openPoints.includes(inPoint));\n    return openPoints.includes(inPoint);\n  }\n  //having an outDir and outPoint in this case is pointless, but not so with the straight and cross\n  // direction(inDir) {\n  //   let corner = this.orientationArr[this.orientationIndex].corner;\n  //   if (\n  //     (corner === \"topLeft\" && inDir === \"down\") ||\n  //     (corner === \"bottomLeft\" && inDir === \"up\")\n  //   ) {\n  //     this.outDir = \"left\";\n  //   }\n  //   if (\n  //     (corner === \"topRight\" && inDir === \"left\") ||\n  //     (corner === \"topLeft\" && inDir === \"right\")\n  //   ) {\n  //     this.outDir = \"up\";\n  //   }\n\n  //   if (\n  //     (corner === \"topRight\" && inDir === \"down\") ||\n  //     (corner === \"bottomRight\" && inDir === \"up\")\n  //   ) {\n  //     this.outDir = \"right\";\n  //   }\n\n  //   if (\n  //     (corner === \"bottomLeft\" && inDir === \"right\") ||\n  //     (corner === \"bottomRight\" && inDir === \"left\")\n  //   ) {\n  //     this.outDir = \"down\";\n  //   }\n  // }\n}\n\nmodule.exports = Elbow;\n","const Shape = require(\"./shape\");\n\nclass Straight {\n  constructor(index, ctx, isFull = false) {\n    this.orientationIndex = index;\n    this.ctx = ctx;\n    this.isFull = isFull;\n    this.drawSludge = this.drawSludge.bind(this);\n    this.asyncDrawSludge = this.asyncDrawSludge.bind(this);\n    this.orientationArr = [\n      {\n        offset_x_1: 25,\n        offset_y_1: 0,\n        offset_x_2: 25,\n        offset_y_2: 50,\n        openPoints: [\"top\", \"bottom\"],\n        corner: \"upDown\"\n      },\n      {\n        offset_x_1: 0,\n        offset_y_1: 25,\n        offset_x_2: 50,\n        offset_y_2: 25,\n        openPoints: [\"left\", \"right\"],\n        corner: \"leftRight\"\n      }\n    ];\n    this.corner = this.orientationArr[this.orientationIndex].corner;\n    this.outPoint = \"\";\n    this.outDir = \"\";\n    this.startX = null;\n    this.startY = null;\n  }\n\n  draw(ctx, x, y) {\n    if (!this.isFull) {\n      let orientation = this.orientationArr[this.orientationIndex];\n      ctx.clearRect(x + 1, y + 1, 49, 49);\n      ctx.beginPath();\n      ctx.moveTo(x + orientation.offset_x_1, y + orientation.offset_y_1);\n      ctx.lineTo(x + orientation.offset_x_2, y + orientation.offset_y_2);\n      ctx.lineWidth = 15;\n      ctx.stroke();\n    }\n  }\n\n  async drawSludge(ctx, x, y, prevDir, sludgeStep, index) {\n    this.isFull = true;\n    let orientation = this.orientationArr[index];\n    let nextSpaceArr = new Array(5);\n\n    if (prevDir === \"right\") {\n      nextSpaceArr[0] = 0;\n      nextSpaceArr[1] = x + 50;\n      nextSpaceArr[2] = x + 50 + sludgeStep;\n      nextSpaceArr[3] = y;\n      nextSpaceArr[4] = y + 50;\n    }\n    if (prevDir === \"left\") {\n      nextSpaceArr[0] = 2;\n      nextSpaceArr[1] = x - 50 - sludgeStep;\n      nextSpaceArr[2] = x - 50;\n      nextSpaceArr[3] = y - 50 - sludgeStep;\n      nextSpaceArr[4] = y - 50;\n    }\n    if (prevDir === \"down\") {\n      nextSpaceArr[0] = 1;\n      nextSpaceArr[1] = x;\n      nextSpaceArr[2] = x + 50;\n      nextSpaceArr[3] = y + 50;\n      nextSpaceArr[4] = y + 50 + sludgeStep;\n    }\n    if (prevDir === \"up\") {\n      nextSpaceArr[0] = 3;\n      nextSpaceArr[1] = x;\n      nextSpaceArr[2] = x + 50;\n      nextSpaceArr[3] = y - 50 - sludgeStep;\n      nextSpaceArr[4] = y;\n    }\n    if (prevDir === \"down\" || prevDir === \"right\") {\n      sludgeStep = sludgeStep;\n    }\n    if (prevDir === \"up\" || prevDir === \"left\") {\n      sludgeStep = 50 - sludgeStep;\n    }\n\n    await this.sleepFunction(30);\n    ctx.beginPath();\n    if (prevDir === \"down\") {\n      ctx.moveTo(x + orientation.offset_x_1, y + orientation.offset_y_1);\n      ctx.lineTo(x + orientation.offset_x_2, y + sludgeStep);\n      nextSpaceArr[0] = 1;\n    } else if (prevDir === \"up\") {\n      ctx.moveTo(x + orientation.offset_x_2, y + orientation.offset_y_2);\n      ctx.lineTo(x + orientation.offset_x_1, y + sludgeStep);\n      nextSpaceArr[0] = 3;\n    } else if (prevDir === \"left\") {\n      debugger;\n      ctx.moveTo(x + orientation.offset_x_2, y + orientation.offset_y_2);\n      ctx.lineTo(x + sludgeStep, y + orientation.offset_y_1);\n      nextSpaceArr[0] = 2;\n    } else if (prevDir === \"right\") {\n      ctx.moveTo(x + orientation.offset_x_1, y + orientation.offset_y_1);\n      ctx.lineTo(x + sludgeStep, y + orientation.offset_y_2);\n      nextSpaceArr[0] = 0;\n    }\n\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = \"#32CD32\";\n    ctx.stroke();\n    ctx.strokeStyle = \"#000000\";\n    if (sludgeStep < 50) {\n      return this.asyncDrawSludge(\n        this.ctx,\n        x,\n        y,\n        prevDir,\n        sludgeStep + 0.25,\n        index\n      );\n    } else {\n      console.log(\"done filling STRAIGHT PIPE!\", nextSpaceArr);\n      return nextSpaceArr;\n    }\n  }\n  sleepFunction(ms) {\n    return new Promise(res => setTimeout(res, ms));\n  }\n  asyncDrawSludge(ctx, x, y, prevDir, sludgeStep, index) {\n    return this.drawSludge(ctx, x, y, prevDir, sludgeStep, index);\n  }\n\n  validFlow(inDir) {\n    console.log(\"INDIR: \", inDir);\n    let inPoint;\n    switch (inDir) {\n      case \"up\":\n        inPoint = \"bottom\";\n        break;\n      case \"down\":\n        inPoint = \"top\";\n        break;\n      case \"right\":\n        inPoint = \"left\";\n        break;\n      case \"left\":\n        inPoint = \"right\";\n        break;\n    }\n    let openPoints = this.orientationArr[this.orientationIndex].openPoints;\n    // console.log(\"straight\", openPoints.includes(inPoint));\n    return openPoints.includes(inPoint);\n  }\n  direction(inDir) {\n    if (inDir === \"down\" && this.orientationIndex === 0) {\n      this.outDir = \"down\";\n    }\n    if (inDir === \"up\" && this.orientationIndex === 0) {\n      this.outDir = \"up\";\n    }\n    if (inDir === \"right\" && this.orientationIndex === 1) {\n      this.outDir = \"right\";\n    }\n    if (this.inDir === \"left\" && this.orientationIndex === 1) {\n      this.outDir = \"left\";\n    }\n  }\n}\n\nmodule.exports = Straight;\n","const Shape = require(\"./shape\");\n\nclass Cross {\n  constructor(id, ctx) {\n    this.ctx = ctx;\n    this.orientationIndex = id;\n\n    this.drawSludge = this.drawSludge.bind(this);\n    this.asyncDrawSludge = this.asyncDrawSludge.bind(this);\n  }\n\n  draw(ctx, x, y) {\n    ctx.clearRect(x + 1, y + 1, 49, 49);\n    ctx.beginPath();\n    ctx.moveTo(x + 25, y + 0);\n    ctx.lineTo(x + 25, y + 50);\n    ctx.moveTo(x + 0, y + 25);\n    ctx.lineTo(x + 50, y + 25);\n    ctx.lineWidth = 15;\n    ctx.stroke();\n  }\n  direction(inDir) {\n    return inDir;\n  }\n  async drawSludge(ctx, x, y, prevDir, sludgeStep, index) {\n    let newOffset;\n    let offset_x_1, offset_y_1, offset_x_2, offset_y_2;\n    const nextSpaceArr = new Array(5);\n    if (prevDir === \"down\" || prevDir === \"right\") {\n      newOffset = sludgeStep;\n    }\n    if (prevDir === \"up\" || prevDir === \"left\") {\n      newOffset = 50 - sludgeStep;\n    }\n    if (prevDir === \"left\") {\n      offset_x_1 = 50;\n      offset_x_2 = newOffset;\n      nextSpaceArr[0] = 2;\n      nextSpaceArr[1] = x - 50;\n      nextSpaceArr[2] = x;\n      nextSpaceArr[3] = y;\n      nextSpaceArr[4] = y + 50;\n    }\n    if (prevDir === \"right\") {\n      offset_x_1 = 0;\n      offset_x_2 = newOffset;\n      nextSpaceArr[0] = 0;\n      nextSpaceArr[1] = x + 50;\n      nextSpaceArr[2] = x + 100;\n      nextSpaceArr[3] = y;\n      nextSpaceArr[4] = y + 50;\n    }\n    if (prevDir === \"up\") {\n      offset_y_1 = 50;\n      offset_y_2 = newOffset;\n      nextSpaceArr[0] = 3;\n      nextSpaceArr[1] = x;\n      nextSpaceArr[2] = x + 50;\n      nextSpaceArr[3] = y - 50;\n      nextSpaceArr[4] = y;\n    }\n    if (prevDir === \"down\") {\n      offset_y_1 = 0;\n      offset_y_2 = newOffset;\n      nextSpaceArr[0] = 1;\n      nextSpaceArr[1] = x;\n      nextSpaceArr[2] = x + 50;\n      nextSpaceArr[3] = y + 50;\n      nextSpaceArr[4] = y + 100;\n    }\n    await this.sleepFunction(30);\n\n    ctx.beginPath();\n    if (prevDir === \"up\" || prevDir === \"down\") {\n      offset_x_1 = 25;\n      offset_x_2 = 25;\n    }\n    if (prevDir === \"left\" || prevDir === \"right\") {\n      offset_y_1 = 25;\n      offset_y_2 = 25;\n    }\n    ctx.moveTo(x + offset_x_1, y + offset_y_1);\n    ctx.lineTo(x + offset_x_2, y + offset_y_2);\n\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = \"#32CD32\";\n    ctx.stroke();\n    ctx.strokeStyle = \"#000000\";\n\n    if (sludgeStep < 50) {\n      return this.asyncDrawSludge(x, y, prevDir, sludgeStep + 0.25, index);\n    } else {\n      console.log(\"done filling CROSS PIPE!:\", nextSpaceArr);\n      return nextSpaceArr;\n    }\n  }\n  sleepFunction(ms) {\n    return new Promise(res => setTimeout(res, ms));\n  }\n\n  asyncDrawSludge(x, y, prevDir, sludgeStep, index) {\n    return this.drawSludge(this.ctx, x, y, prevDir, sludgeStep, index);\n  }\n}\n\nmodule.exports = Cross;\n","const Board = require(\"./board\");\n\nclass Game {\n  constructor(board) {\n    this.board = board;\n    this.isGameOver = false;\n    this.start = this.start.bind(this);\n    this.play = this.play.bind(this);\n    this.dirString = \"\";\n    this.directionOptionsObj = {\n      0: \"right\",\n      1: \"down\",\n      2: \"left\",\n      3: \"up\"\n    };\n  }\n  start() {\n    let date = new Date();\n    let timeNow = date.getTime();\n    this.play();\n  }\n\n  async play() {\n    debugger;\n    let entryReturn = await this.board.fillEntryPipe();\n    console.log(\"RETURN FORM ASYNC:\", entryReturn);\n    let coordinateArr = entryReturn.split(\",\");\n    let direction = this.directionOptionsObj[coordinateArr[0]];\n    console.log(\"direction\", direction);\n    let nextShape = this.board.findDirection(coordinateArr.slice(1), direction);\n    console.log(\"nextShape\", nextShape);\n\n    while (this.board.getValidFlow(direction, nextShape)) {\n      let coordinateArr = await this.board.fillPipes(direction, nextShape);\n      console.log(\"GAME FILL PIPES RETURN\", coordinateArr);\n\n      // console.log(\"check\", coordinateArr[0]);\n      direction = this.directionOptionsObj[coordinateArr[0]];\n      console.log(\"direction\", direction);\n      console.log(\"from return of fill pipes slice: \", coordinateArr.slice(1));\n      nextShape = this.board.findDirection(coordinateArr.slice(1));\n      console.log(\"NEXTSHAPE IN GAME, FROM board.findDirection: \", nextShape);\n      await this.sleepFunction(30);\n      console.log(\"AFTER SLEEP\");\n    }\n    console.log(\"game over\");\n    return;\n  }\n\n  sleepFunction(ms) {\n    return new Promise(res => setTimeout(res, ms));\n  }\n}\n\nmodule.exports = Game;\n"],"sourceRoot":""}